(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{357:function(e,t,i){e.exports=i.p+"assets/img/oauth-actors.f0bcf0fe.png"},358:function(e,t,i){e.exports=i.p+"assets/img/oauth-scopes.c65007c8.png"},359:function(e,t,i){e.exports=i.p+"assets/img/oidc-flow.eb0b515e.png"},360:function(e,t,i){e.exports=i.p+"assets/img/identity_broker_flow.adc30159.png"},361:function(e,t,i){e.exports=i.p+"assets/img/auth-workflow.d2b82051.png"},362:function(e,t,i){e.exports=i.p+"assets/img/api-flow.0ca3e6b4.png"},407:function(e,t,i){"use strict";i.r(t);var s=i(42),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"identity-and-access-management-iam"}},[e._v("Identity and Access Management (IAM)")]),e._v(" "),s("p",[s("strong",[e._v("Disclaimer:")]),e._v(" This content has been gathered from lots of different posts!")]),e._v(" "),s("p",[e._v("IAM == Authentication and Authorization")]),e._v(" "),s("p",[e._v("Unlike a traditional monolithic structure that may have a single security portal, microservices pose many problems. Should each service have it’s own independent security firewall? How should identity be distributed between microservices and throughout my entire system? What is the most efficient method for the exchange of user data?")]),e._v(" "),s("p",[e._v("There are smart techniques that leverage common technologies to not only authorize but perform delegation across your entire system.")]),e._v(" "),s("p",[e._v("We implement "),s("strong",[e._v("OAuth")]),e._v(" and "),s("strong",[e._v("OpenID Connect")]),e._v(" flows using "),s("strong",[e._v("JSON Web Tokens")]),e._v(" to achieve the end goal of creating a distributed authentication mechanism for microservices — a process of managing identity where everything is self-contained, standardized, secure, and best of all — easy to replicate.")]),e._v(" "),s("p",[e._v("In this lesson we will learn following:")]),e._v(" "),s("ol",[s("li",[e._v("Security claims of microservices architecture")]),e._v(" "),s("li",[e._v("OAuth")]),e._v(" "),s("li",[e._v("OpenID Connect")]),e._v(" "),s("li",[e._v("JWT")]),e._v(" "),s("li",[e._v("Common Mistakes")]),e._v(" "),s("li",[e._v("Authorization per Microservice")]),e._v(" "),s("li",[e._v("Multifactor Authentication")]),e._v(" "),s("li",[e._v("Identity Brokering")]),e._v(" "),s("li",[e._v("Threat Model Mitigation")])]),e._v(" "),s("h2",{attrs:{id:"_1-security-claims-of-microservice-architecture"}},[e._v("1. Security claims of microservice architecture")]),e._v(" "),s("p",[e._v("Before digging into OAuth2; it’s important to clarify the claims to a solid security solution.")]),e._v(" "),s("ol",[s("li",[s("p",[s("strong",[e._v("Central authentication:")]),e._v("\nSince microservices is about building mostly independent and autonomous applications, we want to have a consistent authentication experience, so the user won’t notice his requests are served by different applications with possibly individual security configuration.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("Statelessness:")]),e._v("\nThe core benefit of building microservices is scalability. So the chosen security solution shouldn’t affect this. Holding the users session state on server becomes a tricky task, so a stateless solution is highly preferred in this scenario.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("User/machine access distinction:")]),e._v("\nThere is a need of having a clear distinction of different users, and also different machines. Using microservice architecture leads to building a large multi-purpose data-center of different domains and resources, so there is a need to restrict different clients, such as native apps, multiple SPAs etc. in their access.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("Fine-grained access control:")]),e._v("\nWhile maintaining centralized roles, there is a need of configuring detailed access control policies in each microservice. A microservice should be unaware of the responsibility of recognizing users, and must just authorize incoming requests.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("Safe from attacks:")]),e._v("\nNo matter how much problems a security solution may solve, it should be strong against vulnerabilities as best as possible.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("Scalability:")]),e._v("\nUsing stateless protocols is not a warranty of the security solution is scalable. In the end, there should not be any single point of failure. A counter-example is a shared auth database or single auth-server-instance, which is hit once per request.")])])]),e._v(" "),s("h2",{attrs:{id:"_2-oauth"}},[e._v("2. OAuth")]),e._v(" "),s("p",[e._v("OAuth should be interpreted not as Authentication, and not as Authorization, but as Delegation. In the web realm, the underlying message is there, yet it also means having the ability to offer, accept, or deny the exchange of data")]),e._v(" "),s("h3",{attrs:{id:"_2-1-oauth-roles-actors"}},[e._v("2.1 OAuth Roles/Actors")]),e._v(" "),s("p",[e._v("OAuth has four main roles/actors:")]),e._v(" "),s("p",[s("img",{attrs:{src:i(357),alt:"OAuth Actors"}})]),e._v(" "),s("ul",[s("li",[e._v("Resource Owner (That means, You)")]),e._v(" "),s("li",[e._v("Client (Means the application you’re using, that accesses your data on the resource server) e.g. web browser")]),e._v(" "),s("li",[e._v("Resource Server (Where your data are stored) e.g. backend REST API")]),e._v(" "),s("li",[e._v("Authorization Server (Responsible for authenticating your identity and gives you an authorization token, so that you can request resource server for your data with this token. this token is called access_token) → e.g. KeyCloak")])]),e._v(" "),s("h4",{attrs:{id:"_2-1-1-clients"}},[e._v("2.1.1 Clients")]),e._v(" "),s("p",[e._v("Clients can be public and confidential.")]),e._v(" "),s("h5",{attrs:{id:"_2-1-1-1-confidential-clients"}},[e._v("2.1.1.1 Confidential Clients")]),e._v(" "),s("p",[e._v("There is a significant distinction between the two in OAuth nomenclature. Confidential clients can be trusted to store a secret. They’re not running on a desktop or distributed through an app store. People can’t reverse engineer them and get the secret key. They’re running in a protected area where end users can’t access them.")]),e._v(" "),s("h5",{attrs:{id:"_2-1-1-2-public-clients"}},[e._v("2.1.1.2 Public Clients")]),e._v(" "),s("p",[e._v("Public clients are browsers, mobile apps, and IoT devices.")]),e._v(" "),s("h3",{attrs:{id:"_2-2-oauth-scopes"}},[e._v("2.2 OAuth Scopes")]),e._v(" "),s("p",[e._v("Scopes are what you see on the authorization screens when an app requests permissions. They’re bundles of permissions asked for by the client when requesting a token. These are coded by the application developer when writing the application.")]),e._v(" "),s("p",[s("img",{attrs:{src:i(358),alt:"OAuth Scopes"}})]),e._v(" "),s("h3",{attrs:{id:"_2-3-oauth-tokens"}},[e._v("2.3 OAuth Tokens")]),e._v(" "),s("p",[s("strong",[e._v("Access Token And Refresh Token")])]),e._v(" "),s("p",[e._v("This two types of token are provided by your authorization server. "),s("strong",[e._v("access_token")]),e._v(" is responsible for accessing your resources from the resource server. This token usually has a little validity time. You can access your data with this token a certain time before it gets expired. So after it expires, you need to request Authorization server for a new access_token with your "),s("strong",[e._v("refresh_token")]),e._v(", "),s("em",[e._v("client id, and client secret")]),e._v(", so that you don’t need to send user credentials again and again. Refresh token has more validation time than Access Token. Typically 7-90 days, depends on you.")]),e._v(" "),s("p",[e._v("So we can say:")]),e._v(" "),s("ul",[s("li",[e._v("The responsibility of access token is to access data before it gets expired.")]),e._v(" "),s("li",[e._v("The responsibility of Refresh Token is to request for a new access token when the access token is expired.")])]),e._v(" "),s("p",[e._v("Access tokens are the token the client uses to access the Resource Server (API). They’re meant to be short-lived. Think of them in hours and minutes, not days and month. You don’t need a confidential client to get an access token. You can get access tokens with public clients. They’re designed to optimize for internet scale problems. Because these tokens can be short lived and scale out, they can’t be revoked, you just have to wait for them to time out.")]),e._v(" "),s("p",[e._v("The other token is the refresh token. This is much longer-lived; days, months, years. This can be used to get new tokens. To get a refresh token, applications typically require confidential clients with authentication.")]),e._v(" "),s("p",[e._v("Refresh tokens can be revoked. When revoking an application’s access in a dashboard, you’re killing its refresh token. This gives you the ability to force the clients to rotate secrets. What you’re doing is you’re using your refresh token to get new access tokens and the access tokens are going over the wire to hit all the API resources. Each time you refresh your access token you get a new cryptographically signed token. Key rotation is built into the system.")]),e._v(" "),s("p",[e._v("The OAuth spec doesn’t define what a token is. It can be in whatever format you want. Usually though, you want these tokens to be JSON Web Tokens (a standard). In a nutshell, a JWT (pronounced “jot”) is a secure and trustworthy standard for token authentication. JWTs allow you to digitally sign information (referred to as claims) with a signature and can be verified at a later time with a secret signing key.")]),e._v(" "),s("h4",{attrs:{id:"what-will-happen-if-my-tokens-are-compromised"}},[e._v("What will happen if my tokens are compromised?")]),e._v(" "),s("p",[e._v("Since you can get access to your data with access_token, if it’s compromised then the hacker will get a very limited ability to get access to resources since it’ll be expired very soon.")]),e._v(" "),s("p",[e._v("If the refresh token is compromised, your resources are still safe because client id and client secret are needed to request for aceess_token, to get access to resources.")]),e._v(" "),s("h3",{attrs:{id:"_2-4-oauth-grant-types-flows-when-and-why"}},[e._v("2.4 OAuth Grant Types / Flows - When and Why")]),e._v(" "),s("ol",[s("li",[e._v("Authorization Code")]),e._v(" "),s("li",[e._v("Implicit (e.g. browser to keycloak)")]),e._v(" "),s("li",[e._v("Resource Owner Password")]),e._v(" "),s("li",[e._v("Client Credential (e.g. backend microservice to keycloak)")])]),e._v(" "),s("h4",{attrs:{id:"_1-authorization-code"}},[s("strong",[e._v("1. Authorization Code:")])]),e._v(" "),s("p",[e._v("The Authorization Code flow is the most powerful and most secure by default. When the application redirects the user to the Identity Provider to authenticate, the IdP passes back a short-lived, one-time use authorization code. The application uses the authorization code to retrieve the Access Token.")]),e._v(" "),s("p",[e._v("The important part is twofold:")]),e._v(" "),s("ul",[s("li",[e._v("First, by the time the user sees the authorization code, it’s already been consumed and therefore can’t be used again.")]),e._v(" "),s("li",[e._v("Second, the Access Token is kept by the application in the backend. Assuming the application is built securely, a malicious user has to find another way to attack it.")])]),e._v(" "),s("p",[e._v("Unfortunately, this doesn’t work for client side applications such as many Javascript apps or most mobile apps as the application itself can be attacked or decompiled for sensitive information. Therefore, we need a different approach.")]),e._v(" "),s("h4",{attrs:{id:"_2-implicit"}},[s("strong",[e._v("2. Implicit:")])]),e._v(" "),s("p",[e._v("The Implicit flow is designed specifically for mobile apps or client side Javascript apps where embedded credentials could be compromised. The mechanics are simple in that the application redirects the user to the Identity Provider to authenticate, the IdP passes back token(s), and the application uses it according to the scopes it has.")]),e._v(" "),s("p",[e._v("Since it’s quite likely that the user could interact with the token(s), it’s important that our use cases reflect that. If we have a banking app, allowing the send_wire_transfers_to_russia scope may be a bad idea unless we have additional factors baked into our authentication process to validate that the right user is using it. The next time you lose your phone, you’ll appreciate that.")]),e._v(" "),s("p",[e._v("As a result, this is often used for OpenID Connect scenarios where a user wants to provide trusted profile information to a third party but not necessarily access or permissions to other systems. Since the underlying concepts are the same and the implementation looks very similar, it’s most of the benefit for the same effort.")]),e._v(" "),s("h4",{attrs:{id:"_3-resource-owner-password"}},[s("strong",[e._v("3. Resource Owner Password:")])]),e._v(" "),s("p",[e._v("Compared to the previous grant types, Resource Owner Password makes me nervous. With both the Authorization Code and Implicit flows, the application redirects the user to the Identity Provider to submit their username and password. As a result, the application never sees their credentials. With the Resource Owner Password flow, the application itself accepts the credentials and submits them on behalf of the user.")]),e._v(" "),s("p",[e._v("If the application is malicious or even just poorly developed, it could store those credentials and compromise the user’s information. Therefore, you should only use this if you’re building applications for your users to interact with your legacy systems. For example, a bank may implement this for an internal employee portal.")]),e._v(" "),s("p",[e._v("But remember: Fundamentally, you’re training users to put their credentials into applications they may not trust which is a bad habit at best and a security risk at all times.")]),e._v(" "),s("h4",{attrs:{id:"_4-client-credential"}},[s("strong",[e._v("4. Client Credential:")])]),e._v(" "),s("p",[e._v("The Client Credential grant type is designed exclusively for backend server to server operations. Think of it as a server’s username and password. Conceptually, it’s not far from how your application connects to other backend systems such as your database or Twilio. The benefit is that your OAuth provider can return configuration information or other details within the token itself.")]),e._v(" "),s("p",[e._v("Finally, since there’s not a user involved, it doesn’t support OpenID Connect.")]),e._v(" "),s("p",[e._v("It's used for communication from microservices to keycloak.")]),e._v(" "),s("h3",{attrs:{id:"_2-5-oauth-is-not-an-authentication-protocol"}},[e._v("2.5 OAuth is not an Authentication Protocol")]),e._v(" "),s("p",[e._v("To summarize some of the misconceptions of OAuth 2.0: it’s not backwards compatible with OAuth 1.0. It replaces signatures with HTTPS for all communication. When people talk about OAuth today, they’re talking about OAuth 2.0.")]),e._v(" "),s("p",[e._v("Because OAuth is an authorization framework and not a protocol, you may have interoperability issues. There are lots of variances in how teams implement OAuth and you might need custom code to integrate with vendors.")]),e._v(" "),s("p",[e._v("OAuth 2.0 is not an authentication protocol.")]),e._v(" "),s("p",[e._v("We’ve been talking about delegated authorization this whole time. "),s("strong",[e._v("It’s not about authenticating the user, and this is key. OAuth 2.0 alone says absolutely nothing about the user. You just have a token to get access to a resource.")])]),e._v(" "),s("h2",{attrs:{id:"_3-openid-connect"}},[e._v("3. OpenID Connect")]),e._v(" "),s("p",[e._v("To solve the pseudo authentication problem, the best parts of OAuth 2.0, Facebook Connect, and SAML 2.0 were combined to create OpenID Connect. OpenID Connect (OIDC) extends OAuth 2.0 with a "),s("strong",[e._v("new signed id_token")]),e._v(" for the client and a UserInfo endpoint to fetch user attributes. Unlike SAML, OIDC provides a standard set of scopes and claims for identities. Examples include: profile, email, address, and phone.")]),e._v(" "),s("p",[e._v("Request")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("GET https://accounts.google.com/o/oauth2/auth?\nscope=openid email&\nredirect_uri=https://app.example.com/oauth2/callback&\nresponse_type=code&\nclient_id=812741506391&\nstate=af0ifjsldkj\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("Response")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("HTTP/1.1 302 Found\nLocation: https://app.example.com/oauth2/callback?\ncode=MsCeLvIaQm6bTrgtp7&state=af0ifjsldkj\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("The code returned is the authorization grant and state is to ensure it's not forged and it's from the same request.")]),e._v(" "),s("p",[e._v("And the authorization grant for tokens response contains an ID token.")]),e._v(" "),s("p",[e._v("Request")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("POST /oauth2/v3/token HTTP/1.1\nHost: www.googleapis.com\nContent-Type: application/x-www-form-urlencoded\n\ncode=MsCeLvIaQm6bTrgtp7&client_id=812741506391&\n  client_secret={client_secret}&\n  redirect_uri=https://app.example.com/oauth2/callback&\n  grant_type=authorization_code\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br")])]),s("p",[e._v("Response")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{\n  "access_token": "2YotnFZFEjr1zCsicMWpAA",\n  "token_type": "Bearer",\n  "expires_in": 3600,\n  "refresh_token": "tGzv3JOkF0XG5Qx2TlKWIA",\n  "id_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ..."\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("You can see this is layered nicely on top of OAuth to give back an ID token as a structured token. An ID token is a JSON Web Token (JWT). A JWT (aka “jot”) is much smaller than a giant XML-based SAML assertion and can be efficiently passed around between different devices. A JWT has three parts: a header, a body, and a signature. The header says what algorithm was used to sign it, the claims are in the body, and its signed in the signature.")]),e._v(" "),s("p",[e._v("An Open ID Connect flow involves the following steps:")]),e._v(" "),s("ol",[s("li",[e._v("Discover OIDC metadata")]),e._v(" "),s("li",[e._v("Perform OAuth flow to obtain id token and access token")]),e._v(" "),s("li",[e._v("Get JWT signature keys and optionally dynamically register the Client application")]),e._v(" "),s("li",[e._v("Validate JWT ID token locally based on built-in dates and signature")]),e._v(" "),s("li",[e._v("Get additional user attributes as needed with access token")])]),e._v(" "),s("p",[s("img",{attrs:{src:i(359),alt:"OIDC Flow"}})]),e._v(" "),s("h3",{attrs:{id:"the-id-token-identity-token"}},[e._v("The ID Token / Identity Token")]),e._v(" "),s("p",[e._v("You will get id token if you are using scope as openid. Id token is specific to openid scope. With openid scope you can get both id token and access token.")]),e._v(" "),s("p",[e._v("The primary extension that OpenID Connect makes to OAuth 2.0 to enable End-Users to be Authenticated is the ID Token data structure. The ID Token is a security token that contains Claims(claims are name/value pairs that contain information about a user) about the Authentication of an End-User by an Authorization Server when using a Client, and potentially other requested Claims. The ID Token is represented as a JSON Web Token (JWT)")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('{\n   "iss": "https://server.example.com",\n   "sub": "24400320",\n   "aud": "s6BhdRkqt3",\n   "nonce": "n-0S6_WzA2Mj",\n   "exp": 1311281970,\n   "iat": 1311280970,\n   "auth_time": 1311280969,\n   "acr": "urn:mace:incommon:iap:silver"\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br")])]),s("p",[e._v("The above is default JWT claims, in addition to that, if you requested claims from service provider then you will get those as well.")]),e._v(" "),s("p",[e._v("An id_token is a JWT, per the OIDC Specification. This means that:")]),e._v(" "),s("ul",[s("li",[e._v("identity information about the user is encoded right into the token and")]),e._v(" "),s("li",[e._v("the token can be definitively verified to prove that it hasn’t been tampered with.")])]),e._v(" "),s("p",[e._v("There’s a set of "),s("a",{attrs:{href:"http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation",target:"_blank",rel:"noopener noreferrer"}},[e._v("rules"),s("OutboundLink")],1),e._v(" in the specification for validating an id_token. Among the claims encoded in the id_token is an expiration (exp), which must be honored as part of the validation process. Additionally, the signature section of JWT is used in concert with a key to validate that the entire JWT has not been tampered with in any way.")]),e._v(" "),s("h2",{attrs:{id:"_4-jwt"}},[e._v("4. JWT")]),e._v(" "),s("p",[e._v("JSON Web Tokens, commonly known as JWTs, are tokens that are used to authenticate users on applications. This technology has gained popularity over the past few years because it enables backends to accept requests simply by validating the contents of these JWTs. That is, applications that use JWTS no longer have to hold cookies or other session data about their users. This characteristic facilitates scalability while keeping applications secure.")]),e._v(" "),s("p",[e._v("It contains:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("user's identity")]),e._v(" (subject id, name, group, roles, etc.) and")]),e._v(" "),s("li",[e._v("some "),s("strong",[e._v("metadata")]),e._v(" relatives to the authorization process (issuer, time to live, etc.).")])]),e._v(" "),s("p",[s("strong",[e._v("JWT Are Signed! Not Encrypted")])]),e._v(" "),s("p",[e._v("A JSON Web Token is comprised of three parts:")]),e._v(" "),s("ul",[s("li",[e._v("the header,")]),e._v(" "),s("li",[e._v("payload, and")]),e._v(" "),s("li",[e._v("Signature.")])]),e._v(" "),s("p",[e._v("The format of a JWT is "),s("code",[e._v("header.payload.signature")]),e._v(".")]),e._v(" "),s("p",[e._v("The very important thing to note here, is that, this token is signed by the HMACSHA256 algorithm, and the header and payload are Base64URL encoded, it is not encrypted. If I go to jwt.io, paste this token and select the HMACSHA256 algorithm, I could decode the token and read its contents. Therefore, it should go without saying that sensitive data, such as passwords, should never be stored in the payload.")]),e._v(" "),s("p",[e._v("During the authentication process, when a user successfully logs in using their credentials, a JSON Web Token is returned and must be saved locally (typically in local storage). Whenever the user wants to access a protected route or resource (an endpoint), the user agent (e.g. browser) must send the JWT, usually in the Authorization header using the Bearer schema, along with the request.")]),e._v(" "),s("p",[e._v("When a backend server receives a request with a JWT, the first thing to do is to validate the token. This consists of a series of steps, and if any of these fails then the request must be rejected. The following list shows the validation steps needed:")]),e._v(" "),s("ol",[s("li",[e._v("Check that the JWT is well formed.")]),e._v(" "),s("li",[e._v("Check the signature.")]),e._v(" "),s("li",[e._v("Validate the standard claims.")]),e._v(" "),s("li",[e._v("Check the Client permissions (scopes).")])]),e._v(" "),s("p",[e._v("JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA.")]),e._v(" "),s("p",[e._v("Token based authentication schema’s became immensely popular in recent times, as they provide important benefits when compared to sessions/cookies:")]),e._v(" "),s("ul",[s("li",[e._v("CORS")]),e._v(" "),s("li",[e._v("No need for CSRF protection")]),e._v(" "),s("li",[e._v("Better integration with mobile")]),e._v(" "),s("li",[e._v("Reduced load on authorization server")]),e._v(" "),s("li",[e._v("No need for distributed session store")])]),e._v(" "),s("p",[e._v("Some trade-offs have to be made with this approach:")]),e._v(" "),s("ul",[s("li",[e._v("More vulnerable to XSS attacks")]),e._v(" "),s("li",[e._v("Access token can contain outdated authorization claims (e.g when some of the user privileges are revoked)")]),e._v(" "),s("li",[e._v("Access tokens can grow in size in case of increased number of claims")]),e._v(" "),s("li",[e._v("File download API can be tricky to implement")]),e._v(" "),s("li",[e._v("True statelessness and revocation are mutually exclusive")])]),e._v(" "),s("p",[e._v("JWT Authentication flow is very simple:")]),e._v(" "),s("ul",[s("li",[e._v("User obtains Refresh and Access tokens by providing credentials to the Authorization server")]),e._v(" "),s("li",[e._v("User sends Access token with each request to access protected API resource")]),e._v(" "),s("li",[e._v("Access token is signed and contains user identity (e.g. user id) and authorization claims.")])]),e._v(" "),s("h3",{attrs:{id:"anatomy-of-a-jwt"}},[e._v("Anatomy of a JWT")]),e._v(" "),s("p",[e._v("If you encounter a JWT in the wild, you’ll notice that it’s separated into three sections, the header, payload, and signature. (Follow along with Stormpath’s open-source Java JWT tool as we dissect the anatomy of a JWT!) Here’s an example of a typical JWT:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\n.\neyJzdWIiOiJ1c2Vycy9Uek1Vb2NNRjRwIiwibmFtZSI6IlJvYmVydCBUb2tlbiBNYW4iLCJzY29wZSI6InNlbGYgZ3JvdXBzL2FkbWlucyIsImV4cCI6IjEzMDA4MTkzODAifQ\n.\n1pVOLQduFWW3muii1LExVBt2TK1-MdRI4QjhKryaDwc\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("In this example, Section 1 is a header which describes the token. Section 2 is the payload, which contains the JWT’s claims, and Section 3 is the signature hash that can be used to verify the integrity of the token (if you have the secret key that was used to sign it).")]),e._v(" "),s("p",[e._v("When we decode the payload we get this nice, tidy JSON object containing the claims of the JWS:")]),e._v(" "),s("p",[e._v('{\n"sub": "users/TzMUocMF4p",\n"name": "Robert Token Man",\n"scope": "self groups/admins",\n"exp": "1300819380"\n}')]),e._v(" "),s("p",[e._v("The claims tell you, at minimum:")]),e._v(" "),s("ul",[s("li",[e._v("Who this person is and the URI to their user resource (the sub claim)")]),e._v(" "),s("li",[e._v("What this person can access with this token (the scope claim)")]),e._v(" "),s("li",[e._v("When the token expires. Your API should be using this when it verifies the token.")])]),e._v(" "),s("p",[e._v("Because the token is signed with a secret key you can verify its signature and implicitly trust what is being claimed.")]),e._v(" "),s("p",[e._v("Within the payload, there are a number of keys with values. These keys are called "),s("strong",[e._v("claims")]),e._v(" and the JWT specification has seven of these specified as “registered” claims. They are:")]),e._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("iss\tIssuer\nsub\tSubject\naud\tAudience\nexp\tExpiration\nnbf\tNot Before\niat\tIssued At\njti\tJWT ID\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("When building a JWT, you can put in any custom claims you wish. The list above simply represents the claims that are reserved both in the key that is used and the expected type.")]),e._v(" "),s("h3",{attrs:{id:"jwt-size"}},[e._v("JWT Size")]),e._v(" "),s("ul",[s("li",[e._v("The biggest disadvantage of token authentication is the size of JWTs.")]),e._v(" "),s("li",[e._v("A session cookie is relatively tiny compared to even the smallest JWT.")]),e._v(" "),s("li",[e._v("Depending on your use case, the size of the token could become problematic if you add many claims to it. Remember, each request to the server must include the JWT along with it.")])]),e._v(" "),s("h3",{attrs:{id:"where-to-store-jwt"}},[e._v("Where to store JWT?")]),e._v(" "),s("ul",[s("li",[e._v("Commonly, the JWT is placed in the browser's "),s("strong",[e._v("local storage")]),e._v(" and this works well for most use cases. Unlike cookies, local storage is sandboxed to a specific domain and its data cannot be accessed by any other domain including subdomains.")]),e._v(" "),s("li",[e._v("You can store the token in a "),s("strong",[e._v("cookie")]),e._v(" instead, but the max size of a cookie is only 4kb so that may be problematic if you have many claims attached to the token")]),e._v(" "),s("li",[e._v("Additionally, you can store the token in "),s("strong",[e._v("session storage")]),e._v(" which is similar to local storage but is cleared as soon as the user closes the browser.")])]),e._v(" "),s("h2",{attrs:{id:"_5-common-mistakes"}},[e._v("5. Common mistakes")]),e._v(" "),s("p",[e._v("Here is a brief list of the very major things a developer should be aware of.")]),e._v(" "),s("ol",[s("li",[s("p",[s("strong",[e._v("Using the same signing key for production and staging:")]),e._v("\nIt is strictly recommended to use different signing keys as much as possible. Once a signing key gets into wrong hands, it is possible to generate full access granting key without knowing login credentials of any user.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("Not using TLS:")]),e._v("\nIf an attacker manages to intercept an access token, he will gain all the rights authorized to this token, until the token expires. There are a lot of ways to achieve that, in particular when there is no TLS encryption. This was not a problem in the days of version 1 of OAuth, because protocol level encryption was forced.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("Using access tokens in URL:")]),e._v("\nAs of standard, access tokens can be either passed by URL, in headers, or in a cookie. From the TLS point of view, all three ways are secure. In practice passing tokens via URL is less secure, since there several ways of getting the URL from records.")])]),e._v(" "),s("li",[s("p",[s("strong",[e._v("Switching to symmetric signing keys:")]),e._v("\nRSA is not required for JWT signing, and Spring Security does provide symmetric token signing as well; which does solve some problems, which make development harder. But this is insecure, since an attacker just needs to get into one single microservice to be able to generate its own JWT tokens.")])])]),e._v(" "),s("p",[e._v("The biggest complaint about OAuth in general comes from Security people. It’s regarding the Bearer tokens and that they can be passed just like session cookies. You can pass it around and you’re good to go, it’s not cryptographically bound to the user. Using JWTs helps because they can’t be tampered with. However, in the end, a JWT is just a string of characters so they can easily be copied and used in an Authorization header.")]),e._v(" "),s("h2",{attrs:{id:"_6-authorization-per-microservice"}},[e._v("6. Authorization per Microservice")]),e._v(" "),s("p",[e._v("Each microservice should not have to do its own authentication, but it does need to do its own authorization.")]),e._v(" "),s("p",[e._v("Each API should keep track of its own object-level permissions, and it can do so without anything more than a pre-validated userid or groupid. Simply record an object or row that has the id of the object, the id of the user or group, and a set of flags for which permissions they have on that object. That way, when a user tries to do an action on an object, we can join to the appropriate permissions object if it exists, and determine what the user can and can't do to that object. The point is, object-level-permissions exists in the microservice database store without extra user context.")]),e._v(" "),s("p",[e._v("Using this approach we do not require extra user information for authorization such as the username and/or email address - that information is stored elsewhere and only required for authentication.")]),e._v(" "),s("p",[e._v("However, Authentication and Authorization are often mixed – which can lead to serious complexity problems down the line. While Authentication answers the question “who are you?”, Authorization is about the question “what can you do?”. Authentication makes a naturally bounded context (or logical service), in that it has a closed role and needs minimal other information, but Authorization is not that simple. The challenge with Authorization is that in order to answer the question “what can you do?”, the system must have knowledge of what things are possible to do. A very common anti-pattern is the creation of an “Authorization Service”, in an attempt to put Authorization concerns into a single place. This can be appealing on the grounds that all the information about a concept is grouped together, however this means that the “Authorization Service” must know about all the functionality of every other service, and the business rules around who can invoke this functionality and based on what conditions. This is a very common source of major architectural problems, as a result of individual services being unable to perform their job autonomously, and a single service (Authorization) having an intimate knowledge of the workings of other services. The purpose when designing services in a service-oriented or microservices architecture is to create independent logically bounded components, that can version independently, and function in isolation. At runtime, service boundaries form fault partitions, where if one service is offline, other services should be able to continue to work. Allowing a single service to hold knowledge about other services violates these principles.")]),e._v(" "),s("p",[e._v("Reference:")]),e._v(" "),s("ul",[s("li",[e._v("http://richardwellum.com/2017/04/authentication-authorization-and-bounded-contexts/")])]),e._v(" "),s("h2",{attrs:{id:"_7-multifactor-authentication"}},[e._v("7. Multifactor Authentication")]),e._v(" "),s("p",[e._v("Multifactor Authentication (MFA) is a method of verifying a user's identity by requiring them to present more than one piece of identifying information. This method provides an additional layer of security, decreasing the likelihood of unauthorized access. The type of information required from the user is typically two or more of the following:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Knowledge")]),e._v(": Something the user knows (e.g. a password)")]),e._v(" "),s("li",[s("strong",[e._v("Possession")]),e._v(": Something the user has (e.g. a cell phone)")]),e._v(" "),s("li",[s("strong",[e._v("Inheritance")]),e._v(": Something the user is (e.g. a fingerprint or retina scan)")])]),e._v(" "),s("h2",{attrs:{id:"_8-identity-brokering"}},[e._v("8. Identity Brokering")]),e._v(" "),s("p",[e._v("An Identity Broker is an intermediary service that connects multiple service providers with different identity providers. As an intermediary service, the identity broker is responsible for creating a trust relationship with an external identity provider in order to use its identities to access internal services exposed by service providers.")]),e._v(" "),s("p",[e._v("From a user perspective, an identity broker provides a user-centric and centralized way to manage identities across different security domains or realms. An existing account can be linked with one or more identities from different identity providers or even created based on the identity information obtained from them.")]),e._v(" "),s("p",[e._v("An identity provider is usually based on a specific protocol that is used to authenticate and communicate authentication and authorization information to their users. It can be a social provider such as Facebook, Google or Twitter. It can be a business partner whose users need to access your services. Or it an be a cloud-based identity service that you want to integrate with.")]),e._v(" "),s("h4",{attrs:{id:"keycloak"}},[e._v("KeyCloak")]),e._v(" "),s("p",[e._v("When using KeyCloak as an identity broker, users are not forced to provide their credentials in order to authenticate in a specific realm. Instead, they are presented with a list of identity providers from which they can authenticate.")]),e._v(" "),s("p",[e._v("You can also configure a default broker. In this case the user will not be given a choice, but instead be redirected directly to the parent broker. The following diagram demonstrates the steps involved when using KeyCloak to broker an external identity provider:")]),e._v(" "),s("p",[s("img",{attrs:{src:i(360),alt:"OAuth Scopes"}})]),e._v(" "),s("ol",[s("li",[e._v("User is not authenticated and requests a protected resource in a client application.")]),e._v(" "),s("li",[e._v("The client applications redirects the user to KeyCloak to authenticate.")]),e._v(" "),s("li",[e._v("At this point the user is presented with the login page where there is a list of identity providers supported by a realm.")]),e._v(" "),s("li",[e._v("User selects one of the identity providers by clicking on its respective button or link.")]),e._v(" "),s("li",[e._v("KeyCloak issues an authentication request to the target identity provider asking for authentication and the user is redirected to the login page of the identity provider. The connection properties and other configuration options for the identity provider were previously set by the administrator in the Admin Console.")]),e._v(" "),s("li",[e._v("User provides his credentials or consent in order to authenticate in the identity provider.")]),e._v(" "),s("li",[e._v("Upon a successful authentication by the identity provider, the user is redirected back to KeyCloak with an authentication response. Usually this response contains a security token that will be used by KeyCloak to trust the authentication performed by the identity provider and retrieve information about the user.")]),e._v(" "),s("li",[e._v("Now KeyCloak is going to check if the response from the identity provider is valid. If valid, it will import and create a new user or just skip that if the user already exists. If it is a new user, KeyCloak may ask the identity provider for information about the user if that info doesn’t already exist in the token. This is what we call identity federation. If the user already exists KeyCloak may ask him to link the identity returned from the identity provider with his existing account. We call this process account linking. What exactly is done is configurable and can be specified by setup of First Login Flow . At the end of this step, KeyCloak authenticates the user and issues its own token in order to access the requested resource in the service provider.")]),e._v(" "),s("li",[e._v("Once the user is locally authenticated, KeyCloak redirects the user to the service provider by sending the token previously issued during the local authentication.")]),e._v(" "),s("li",[e._v("The service provider receives the token from KeyCloak and allows access to the protected resource.")])]),e._v(" "),s("p",[e._v("As you may notice, at the end of the authentication process KeyCloak will always issue its own token to client applications. What this means is that client applications are completely decoupled from external identity providers. They don’t need to know which protocol (eg.: SAML, OpenID Connect, OAuth, etc) was used or how the user’s identity was validated. They only need to know about KeyCloak.")]),e._v(" "),s("h2",{attrs:{id:"_9-threat-model-mitigation"}},[e._v("9. Threat Model Mitigation")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.0/html/server_administration_guide/threat_model_mitigation",target:"_blank",rel:"noopener noreferrer"}},[e._v("KeyCloak Threat Model Mitigation"),s("OutboundLink")],1)]),e._v(" "),s("li",[s("a",{attrs:{href:"https://tools.ietf.org/html/rfc6819",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://tools.ietf.org/html/rfc6819"),s("OutboundLink")],1)])]),e._v(" "),s("h2",{attrs:{id:"_10-others"}},[e._v("10. Others")]),e._v(" "),s("h3",{attrs:{id:"what-are-the-3-tokens"}},[e._v("What are the 3 tokens?")]),e._v(" "),s("p",[e._v("OAuth2 had these two tokens:")]),e._v(" "),s("p",[e._v("(1). Access Token")]),e._v(" "),s("p",[e._v("Access tokens are used as bearer tokens. A bearer token means that the bearer (who hold the access token) can access authorized resources without further identification. Because of this, it’s important that bearer tokens are protected. If I can somehow get ahold of and “bear” your access token, I can pretend as you.")]),e._v(" "),s("p",[e._v("These tokens usually have a short lifespan (dictated by its expiration) for improved security. That is, when the access token expires, the user must authenticate again to get a new access token limiting the exposure of the fact that it’s a bearer token.")]),e._v(" "),s("p",[e._v("(2). Refresh Token")]),e._v(" "),s("p",[e._v("OpenId Connect adds this 3rd token:")]),e._v(" "),s("p",[e._v("(3). ID Token")]),e._v(" "),s("p",[e._v("So, you can see auth is added by OpenID Connect")]),e._v(" "),s("h3",{attrs:{id:"scopes-vs-claims"}},[e._v("Scopes vs Claims")]),e._v(" "),s("p",[e._v("A scope represents the access authorization associated with a particular token with respect to resource servers, resources, and methods on those resources.  Scopes are the OAuth way to explicitly manage the power associated with an access token.  A scope can be controlled by the authorization server and/or the end user in order to limit access to resources for OAuth clients that these parties deem less secure or trustworthy.")]),e._v(" "),s("p",[e._v("Claims are name/value pairs that contain information about a user.")]),e._v(" "),s("h3",{attrs:{id:"how-does-the-resource-server-validate-the-access-token-with-the-auth-server"}},[e._v("How does the Resource Server validate the access token with the Auth Server?")]),e._v(" "),s("p",[e._v('Two options here. The OAuth specification does not dictate the format for tokens and as such, they are considered "opaque".')]),e._v(" "),s("ul",[s("li",[e._v("In this case, the Resource Server must make an introspect request of the Authorization Server to get back the information (like scopes and timeout) that the token represents.")]),e._v(" "),s("li",[e._v("However, the second approach is now more prevalent and is used by most. In this case, the access token is a JWT that has a signature computed using the RS-256 algorithm and a private key used by e.g. KeyCloak. The resource server can use the corresponding public key (which it can obtain using the metadata from the well known endpoint to validate the access token WITHOUT having to make the introspect request of the Authorization Server. This saves a lot of network traffic.")])]),e._v(" "),s("h3",{attrs:{id:"does-the-resource-server-need-to-validate-the-access-token-every-time"}},[e._v("Does the Resource Server need to validate the access token every time?")]),e._v(" "),s("p",[e._v("Yes. But, HOW the validation is done is dependent on the formatting of the token.")]),e._v(" "),s("h3",{attrs:{id:"how-does-the-whole-workflow-look-like"}},[e._v("How does the whole workflow look like?")]),e._v(" "),s("p",[e._v("This diagram depicts pretty nicely:")]),e._v(" "),s("p",[s("img",{attrs:{src:i(361),alt:"OAuth Actors"}})]),e._v(" "),s("h3",{attrs:{id:"is-it-permissible-for-the-access-token-to-be-a-jwt"}},[e._v("Is it permissible for the access token to be a JWT?")]),e._v(" "),s("p",[e._v("Using a JWT as an access token is certainly permissible by spec exactly because the spec does not restrict its format.")]),e._v(" "),s("h3",{attrs:{id:"if-it-is-permissible-according-to-the-spec-are-there-any-additional-considerations-that-would-make-using-a-jwt-as-an-access-token-a-bad-idea"}},[e._v("If it is permissible according to the spec, are there any additional considerations that would make using a JWT as an access token a bad idea?")]),e._v(" "),s("p",[e._v("The idea behind using a JWT as an access token is that it can then be self-contained so that the target can verify the access token and use the associated content without having to go back to the Authorization Server. That is a great property but makes revocation harder. So if your system requires a capability for immediate revocation of access, a JWT is probably not the right choice for an access token (though you can get pretty far by reducing the lifetime of the JWT).")]),e._v(" "),s("p",[e._v("The trick to revocation is to use a refresh token. The refresh token is supplied by the Authorization Server at the same time as your JWT access token, but has a much longer lifetime and - crucially - can only be used in a request to the Authorization Server to get a new access token (without user interaction). E.g. the AS issues a refresh token that lasts 5 hours and an access JWT that lasts 5 minutes. You get 5 minutes worth of requests with no slow AS calls, and a chance to revoke every 5 minutes (when the Access Token expires and the Refresh token is used to request a new one from the AS)")]),e._v(" "),s("h3",{attrs:{id:"what-is-purpose-of-redirect-uri"}},[e._v("What is purpose of Redirect URI?")]),e._v(" "),s("p",[e._v('A redirect URI helps to detect malicious clients and prevents phishing attacks from clients attempting to trick the user into believing the phisher is the client.  The value of the actual redirect URI used in the authorization request has to be presented and is verified when an authorization "code" is exchanged for tokens. This helps to prevent attacks where the authorization "code" is revealed through redirectors and counterfeit web application clients. The authorization server should require public clients and confidential clients using the implicit grant type to pre-register their redirect URIs and validate against the registered redirect URI in the authorization request.')]),e._v(" "),s("h3",{attrs:{id:"what-is-bearer-token"}},[e._v("What is bearer token?")]),e._v(" "),s("p",[e._v("A 'bearer token' is a token that can be used by any client who has received the token (e.g., [RFC6750]).  Because mere possession is enough to use the token, it is important that communication between endpoints be secured to ensure that only authorized endpoints may capture the token.  The bearer token is convenient for client applications, as it does not require them to do anything to use them (such as a proof of identity). Bearer tokens have similar characteristics to web single-sign-on (SSO) cookies used in browsers.")]),e._v(" "),s("h3",{attrs:{id:"what-will-be-api-flow"}},[e._v("What will be API flow?")]),e._v(" "),s("p",[e._v("Here is an example flow:")]),e._v(" "),s("p",[s("img",{attrs:{src:i(362),alt:"API Flow"}})]),e._v(" "),s("p",[e._v("The process is following:")]),e._v(" "),s("ol",[s("li",[e._v("The user is signing in on the client app. He is redirected to the Keycloak login page. He can use his credentials or use a third party identity provider (depending the IAM configuration).")]),e._v(" "),s("li",[e._v("Once logged, Keycloak is issuing an access token and a refresh to the user.")]),e._v(" "),s("li",[e._v("Both tokens are saved by the client app for the next usage.")]),e._v(" "),s("li",[e._v("Now the client application can access to the API by filling the Authorization http header with the access token. The access token is short-lived and must be refreshed before its expiration date. So the client app should verify each time that the access token is not about to expire. In this case, the client app shall use the refresh token to claim a new access token to Keycloak.")]),e._v(" "),s("li",[e._v("Kong validates the access token. It verify the signature, the issuer and the expiration time of the token.")]),e._v(" "),s("li",[e._v("If everything is ok, Kong transfers the request to the backend service. The access token is still carried by the the Authorization header and can be decoded by the backend services to gather information required by the fine grained authorization layer (subject id, group, roles). Note than Kong add the client app ID into the header. This can be useful to the backend service in order to identify where the user comes from.")]),e._v(" "),s("li",[e._v("And the service response is transmitted to the client app through all layers.")])]),e._v(" "),s("h2",{attrs:{id:"references"}},[e._v("References")]),e._v(" "),s("ul",[s("li",[e._v("https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth")]),e._v(" "),s("li",[e._v("https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.0/html/server_administration_guide/identity_broker")])])])}),[],!1,null,null,null);t.default=a.exports}}]);