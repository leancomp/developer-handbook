(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{372:function(e,t,s){e.exports=s.p+"assets/img/test-pyramid-1.f89271e8.png"},373:function(e,t,s){e.exports=s.p+"assets/img/test-pyramid-2.47a8c378.png"},374:function(e,t,s){e.exports=s.p+"assets/img/application-architecture.fcec962f.png"},375:function(e,t,s){e.exports=s.p+"assets/img/test-types.e05b6924.png"},418:function(e,t,s){"use strict";s.r(t);var i=s(42),o=Object(i.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"backend-testing-microservice"}},[e._v("Backend Testing (Microservice)")]),e._v(" "),i("p",[e._v("how to test microservices based applications?")]),e._v(" "),i("blockquote",[i("p",[e._v('There has been a shift in service based architectures over the last few years towards smaller, more focussed "micro" services. There are many benefits with this approach such as the ability to independently deploy, scale and maintain each component and parallelize development across multiple teams. However, once these additional network partitions have been introduced, the testing strategies that applied for monolithic in process applications need to be reconsidered.')])]),e._v(" "),i("p",[i("img",{attrs:{src:s(372),alt:"Testing Pyramid 1"}})]),e._v(" "),i("p",[e._v("Unit tests are fast to execute, give the right level of feedback about what is broken. As you go up the pyramid, the tests are slower and it becomes harder to point out root cause of failures because the surface area is larger.")]),e._v(" "),i("p",[e._v("Its essential point is that you should have many more low-level unit tests than high level end-to-end tests running through a GUI.")]),e._v(" "),i("p",[i("img",{attrs:{src:s(373),alt:"Test Pyramid"}})]),e._v(" "),i("p",[e._v("A common problem is that teams conflate the concepts of end-to-end tests, UI tests, and customer facing tests. These are all orthogonal characteristics. For example a rich javascript UI should have most of its UI behavior tested with javascript unit tests using something like Jasmine. A complex set of business rules could have tests captured in a customer-facing form, but run just on the relevant module much as unit tests are.")]),e._v(" "),i("blockquote",[i("p",[e._v("I always argue that high-level tests are there as a second line of test defense. If you get a failure in a high level test, not just do you have a bug in your functional code, you also have a missing or incorrect unit test. Thus I advise that before fixing a bug exposed by a high level test, you should replicate the bug with a unit test. Then the unit test ensures the bug stays dead.")])]),e._v(" "),i("h1",{attrs:{id:"microservices-can-usually-be-split-into-similar-kinds-of-modules"}},[e._v("Microservices can usually be split into similar kinds of modules")]),e._v(" "),i("p",[i("img",{attrs:{src:s(374),alt:"Architecture"}})]),e._v(" "),i("ul",[i("li",[i("p",[i("strong",[e._v("Resources")]),e._v(" act as mappers between the application protocol exposed by the service and messages to objects representing the domain. Typically, they are thin, with responsibility for sanity checking the request and providing a protocol specific response according to the outcome of the business transaction.")])]),e._v(" "),i("li",[i("p",[e._v("Almost all of the service logic resides in a "),i("strong",[e._v("domain model")]),e._v(" representing the business domain. Of these objects, "),i("strong",[e._v("services")]),e._v(" coordinate across multiple domain activities, whilst "),i("strong",[e._v("repositories")]),e._v(" act on collections of domain entities and are often persistence backed.")])]),e._v(" "),i("li",[i("p",[e._v("If one service has another service as a collaborator, some logic is needed to communicate with the external service. A gateway encapsulates message passing with a remote service, marshalling requests and responses from and to domain objects. It will likely use a client that understands the underlying protocol to handle the request-response cycle.")])]),e._v(" "),i("li",[i("p",[e._v("Except in the most trivial cases or when a service acts as an aggregator across resources owned by other services, a micro-service will need to be able to persist objects from the domain between requests. Usually this is achieved using object relation mapping or more lightweight data mappers depending on the complexity of the persistence requirements. Often, this logic is encapsulated in a set of dedicated objects utilised by repositories from the domain.")])]),e._v(" "),i("li",[i("p",[e._v("A resource receives a request and once validated, calls into the domain to begin handling of the request.")])]),e._v(" "),i("li",[i("p",[e._v("If many modules must be coordinated to complete the business transaction, the resource delegates to a service. Otherwise, it communicates directly with the relevant module.")])]),e._v(" "),i("li",[i("p",[e._v("Connections out to external services require special attention since they cross network boundaries. The system should be resilient to outages of remote components. Gateways contain logic to handle such error cases. Typically, communications with external services are more coarse grained than the equivalent in process communications to prevent API chattiness and latency.")])]),e._v(" "),i("li",[i("p",[e._v("Similarly, communications with external datastores have different design considerations. Whilst a service is often more logically coupled to its datastore than to an external service, the datastore still exists over a network boundary incurring latency and risk of outage.")])]),e._v(" "),i("li",[i("p",[e._v("The presence of network partitions affects the style of testing employed. Tests of these modules can have longer execution times and may fail for reasons outside of the team's control.")])])]),e._v(" "),i("h3",{attrs:{id:"internal-resources"}},[e._v("Internal Resources")]),e._v(" "),i("p",[e._v("are useful for more than just testing...")]),e._v(" "),i("p",[e._v("Though it may seem strange, exposing internal controls as resources can prove useful in a number of cases besides testing such as monitoring, maintenance and debugging. The uniformity of a RESTful API means that many tools already exist for interacting with such resources which can help reduce overall operational complexity.")]),e._v(" "),i("p",[e._v("The kinds of internal resources that are typically exposed include logs, feature flags, database commands and system metrics. Many microservices also include health check resources which provide information about the health of the service and its dependencies, timings for key transactions and details of configuration parameters. A simple ping resource can also be useful to aid in load balancing.")]),e._v(" "),i("p",[e._v("Since these resources are more privileged in terms of the control they have or the information they expose, they often require their own authentication or to be locked down at the network level. By namespacing those parts of the API that form the internal controls using URL naming conventions or by exposing those resources on a different network port, access can be restricted at the firewall level.")]),e._v(" "),i("h1",{attrs:{id:"testing-strategies-for-microservices"}},[e._v("Testing Strategies for Microservices")]),e._v(" "),i("p",[i("img",{attrs:{src:s(375),alt:"Testing Strategies for Microservices"}})]),e._v(" "),i("h2",{attrs:{id:"_1-unit-tests"}},[e._v("1. Unit Tests")]),e._v(" "),i("p",[e._v("Unit tests : exercise the smallest pieces of testable software in the application to determine whether they behave as expected.")]),e._v(" "),i("p",[i("strong",[e._v("Unit tests")]),e._v(" are written to test the behavior of small pieces of your application in isolation (say, a method, or a function, or the interactions between a small group of them). They can usually be run without starting the whole application. They do not hit the database (if your application has one), the filesystem, or the network. They don’t require your application to be running in a production-like environment. Unit tests should run very fast—your whole suite, even for a large application, should be able to run in under ten minutes.")]),e._v(" "),i("h3",{attrs:{id:"testing-domain-or-business-function"}},[e._v("Testing domain or business function")]),e._v(" "),i("p",[e._v("The code in your microservice that performs business function should not make calls to any services external to the application. This code can be tested by using unit tests and a testing framework such as JUnit1. The unit tests should test for behavior and either use the actual objects (if no external calls are needed) or mock the objects involved in any operations.")]),e._v(" "),i("p",[e._v("When writing tests using the actual objects, a simple JUnit test suffices. For creating mocks of objects, you can either use the built-in capabilities of Java EE or use a mocking framework. The @Alternatives annotation2 in the Context and Dependency Injection (CDI) specification enables injection of mock objects instead of the actual beans. Plenty of mocking frameworks are available for Java. For example, JMockit3 is designed to work with JUnit to allow you to mock objects during testing. In the most basic test using JMockit, you can create mocked objects by using the @Mocked annotation and define behavior when this object is called by using the Expectations() function.")]),e._v(" "),i("h2",{attrs:{id:"_2-integration-tests"}},[e._v("2. Integration Tests")]),e._v(" "),i("p",[e._v("Integration tests are used to test the interactions between all the services in the system. The in-depth behavior of the individual services has already been tested at this stage. The consumer driven contract tests should have ensured that the services interact successfully, but these tests identify bugs that have been missed. The tests should check the basic success and error paths of service communication with the application deployed. Use the test data as discussed in the previous section.")]),e._v(" "),i("p",[e._v("Rather than testing all of the services at once, it might still be necessary to mock out some of the services during testing. Test the interaction of two specific services, or a small set of services, adding in mocked behavior when calls are made to outside the set. Mocking the calls to the services outside the group under test is done in the same way as the unit tests on the APIs. The same techniques that are used to start and stop the server or container for contract testing also apply here.")]),e._v(" "),i("p",[e._v("Integration tests : verify the communication paths and interactions between components to detect interface defects.")]),e._v(" "),i("p",[e._v("Integration tests are used to verify the communication across network boundaries. They should test the basic success and failure paths in an exchange. Integration tests can either be run in the same way as unit tests, or by standing up the application on a running server. To run integration tests without starting the server, call the methods that carry JAX-RS annotations directly. During the tests, create mocks for the objects that the resource classes call when a request comes in.")]),e._v(" "),i("p",[e._v("Integration tests should validate the basic success and error paths of the application. Incorrect requests should return useful responses with the appropriate error code.")]),e._v(" "),i("h3",{attrs:{id:"_2-1-gateway-integration-tests"}},[e._v("2.1 Gateway Integration Tests")]),e._v(" "),i("p",[e._v("To verify integration with external gateways or other systems.")]),e._v(" "),i("h4",{attrs:{id:"testing-external-service-requests"}},[e._v("Testing external service requests")]),e._v(" "),i("p",[e._v("Inevitably, your microservice must make calls to external services to complete a request, such as calls to other microservices in the application or services external to the application. The classes to do this construct clients that make the requests and handle any failures. The code can be tested by using two sets of integration tests: One at the single service level and one in the staging environment. Both sets test the basic success and error handling of the client.")]),e._v(" "),i("p",[e._v("The integration tests at the single service level do not require the service under test or the external services to be deployed. To perform the integration tests, mock the response from the external services. If you are using the JAX-RS 2.0 client to make the external requests, this process can be done easily by using the JMockit framework")]),e._v(" "),i("h3",{attrs:{id:"_2-2-persistence-integration-tests"}},[e._v("2.2 Persistence Integration Tests")]),e._v(" "),i("p",[e._v("To verify integration with databases.")]),e._v(" "),i("p",[e._v("In a microservice architecture, each microservice owns its own data. If you follow this guideline, the developers of a microservice are also responsible for any external data stores used. The code that makes requests to the external data store and performs data mapping and validation is contained in the repositories layer. When testing the domain logic, this layer should be mocked. Tests for data requests, data mapping, and validation are done by using integration tests with the microservice and a test data store deployed locally or on a private cloud. The tests check the basic success and error paths for data requests. If the data mapping and validation for your application requires extensive testing, consider separating out this code and testing it using a mocked database client class.")]),e._v(" "),i("h4",{attrs:{id:"test-data"}},[e._v("Test data")]),e._v(" "),i("p",[e._v("The local version of the data store must be populated with data for testing. Think carefully about what data you put in the data store. The data should be structured in the same way as production data but should not be unnecessarily complicated. It must serve the specific purpose of enabling data request tests.")]),e._v(" "),i("h2",{attrs:{id:"_3-component-tests"}},[e._v("3. Component tests")]),e._v(" "),i("p",[i("strong",[e._v("Component tests")]),e._v(" test the behavior of several components of your application. Like unit tests, they don’t always require starting the whole application. However, they may hit the database, the filesystem, or other systems (which may be stubbed out). Component tests typically take longer to run.")]),e._v(" "),i("p",[e._v("Component tests are designed to test an individual microservice as one piece. The component is everything inside the network boundary, so calls to external services are either mocked or are replaced with a “test-service.” There are advantages and disadvantages to both scenarios.")]),e._v(" "),i("p",[i("strong",[e._v("Using mocks")])]),e._v(" "),i("p",[e._v("By mocking the calls to external services, you have fewer test objects to configure. You can easily define the behavior of the mocked system by using frameworks like JMockit, and no tests will fail due to network problems. The disadvantage of this approach is that it does not fully exercise the component because you are intercepting some of the calls, increasing the risk of bugs slipping through.")]),e._v(" "),i("p",[i("strong",[e._v("Test services")])]),e._v(" "),i("p",[e._v("To fully exercise the communication boundaries of your microservice, you can create test services to mimic the external services that are called in production. These test services can also include a test database. The test services can also be used as a reference for consumers of your microservice. The disadvantage of this system is that it requires you to maintain your test services. This technique requires more processor cycles than maintaining a mocking system as you must fully test the test microservice and create a deployment pipeline.")]),e._v(" "),i("p",[e._v("After you are using a mocking framework for other levels of testing, it makes sense to reuse those skills. However, if you do take the mocking approach, you must make sure that the tests in your staging environment exercise inter-service communications effectively.")]),e._v(" "),i("p",[e._v("Limit the scope of the exercised software to a portion of the system under test, manipulating the system through internal code interfaces and using test doubles to isolate the code under test from other components.")]),e._v(" "),i("h2",{attrs:{id:"_4-contract-tests"}},[e._v("4. Contract tests")]),e._v(" "),i("p",[e._v("Verify interactions at the boundary of an external service asserting that it meets the contract expected by a consuming service.")]),e._v(" "),i("p",[e._v("Every service that consumes another service or resource should have a set of contract tests that are run against that resource (especially in staging environments). Given that services evolve independently over time, it is important to ensure that the consumer's contract continues to be satisfied.")]),e._v(" "),i("p",[e._v("These tests are specifically written by the consumer (the client side), and are run and managed as part of the test suite for the consuming service.")]),e._v(" "),i("p",[e._v("Classes that expose JAX-RS endpoints or receive events should be tested by using two types of tests: Integration tests and contract tests.")]),e._v(" "),i("h3",{attrs:{id:"_4-1-consumer-driven-contracts"}},[e._v("4.1 Consumer Driven Contracts")]),e._v(" "),i("p",[e._v("It's nearly impossible for you to know all the ways consumers might use your services. With a "),i("a",{attrs:{href:"http://martinfowler.com/articles/consumerDrivenContracts.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("consumer-driven contract"),i("OutboundLink")],1),e._v(" model, it's the consumer's responsibility to provide a suite of tests that specify what types of interactions are needed and in which format. Your service would then agree to this contract and ensure that it's not broken. This gets rid of dependencies on other services. This approach also enables you to verify that the contract is being fulfilled at build time.")]),e._v(" "),i("p",[e._v("Tools like "),i("a",{attrs:{href:"https://github.com/realestate-com-au/pact",target:"_blank",rel:"noopener noreferrer"}},[e._v("Pact"),i("OutboundLink")],1),e._v(" will give you a better understanding of how you can achieve this type of functionality for developing and testing microservices. Once you have a consumer-driven contract process in place, the next key step in testing microservices is to shift-right into the previously forbidden world of production.")]),e._v(" "),i("p",[e._v("A consumer of a particular service has a set of input and output attributes that it expects the service to adhere to. This set can include data structures, performance, and conversations. The contract is documented by using a tool like Swagger. Generally, have the consumers of a service drive the definition of the contract, which is the origin of the term consumer driven contract.")]),e._v(" "),i("p",[e._v("Consumer driven contract tests are a set of tests to determine whether the contract is being upheld. These tests should validate that the resources expect the input attributes defined in the contract, but also accepts unknown attributes (it should just ignore them). They should also validate that the resources return only those attributes that are defined in the documentation. To isolate the code under test, use mocks for the domain logic.")]),e._v(" "),i("p",[e._v("Maintaining consumer driven contract tests introduces some organizational complexity. If the tests do not accurately test the contract defined, they are useless. In addition, if the contract is out of date, then even the best tests will not result in a useful resource for the consumer. Therefore, it is vital that the consumer driven contract is kept up to date with current consumer needs and that the tests always accurately test the contract.")]),e._v(" "),i("p",[e._v("Contract tests require the actual API to be implemented. This technique requires the application be deployed onto a server.  Use tools such as the Swagger editor4 to create these tests. The Swagger editor can take the API documentation and produce implementations in many different languages.")]),e._v(" "),i("p",[e._v("Another dimension to contract testing is the tests that are run by the consumer. These tests must be run in an environment where the consumer has access to a live version of the service, which is the staging environment.")]),e._v(" "),i("h2",{attrs:{id:"_5-end-to-end-tests"}},[e._v("5. End-to-end tests")]),e._v(" "),i("p",[e._v("Verify that a system meets external requirements and achieves its goals, testing the entire system, from end to end.")]),e._v(" "),i("p",[e._v("End-to-end testing is essential to find the bugs that were missed previously. End-to-end tests should exercise certain “golden paths” through the application. It is unrealistic to test every path through the application with an end-to-end test, so identify the key ones and test those.")]),e._v(" "),i("p",[e._v("A good way to identify these paths through the environment is to review the key external requirements of an application. For example, if your application is an online retail store you might test the following paths:")]),e._v(" "),i("ul",[i("li",[e._v("User logs in")]),e._v(" "),i("li",[e._v("User purchases an item")]),e._v(" "),i("li",[e._v("User views the summary of the order")]),e._v(" "),i("li",[e._v("User cancels the order")])]),e._v(" "),i("p",[e._v("End-to-end testing should also include the user interface. Tools such as SeleniumHQ or Cypress can be used to automate interactions with a web browser for testing.")]),e._v(" "),i("p",[e._v("E2E tests are run in mock/stage environment.")]),e._v(" "),i("h3",{attrs:{id:"_5-1-mock-stage-environment"}},[e._v("5.1 Mock / Stage Environment")]),e._v(" "),i("p",[e._v("This section defines a staging environment as a test environment that is identical (where possible) to the production environment. The build pipeline deploys successfully tested microservices to the staging environment where tests are run to verify the communication across logical boundaries, that is, between microservices.")]),e._v(" "),i("h4",{attrs:{id:"_5-1-1-test-data"}},[e._v("5.1.1 Test data")]),e._v(" "),i("p",[e._v("The staging environment should include any data stores that will be in your production system. The data in this data store will be more complete than at the individual microservice level, as these tests are testing more complicated interactions. Use tools to inject data into tests for you. Tools allow you to have more control over the flow of data around the system")]),e._v(" "),i("h3",{attrs:{id:"_5-2-e2e-automation-tools"}},[e._v("5.2 E2E Automation tools")]),e._v(" "),i("h4",{attrs:{id:"_5-2-1-selenium"}},[e._v("5.2.1 Selenium")]),e._v(" "),i("p",[e._v("Selenium WebDriver is the open source automation tool we all know and love. With a history starting from the humble beginnings of IDE and transforming into Selenium 2.0 a.k.a. Selenium WebDriver, Selenium has become a foundation of many modern software teams' test automation toolkits.")]),e._v(" "),i("p",[e._v("Most are familiar with Selenium's use — it makes direct calls to the browser using each browser's native support for automation. By writing a script in Selenese using the compatible programming languages, you can run tests that work as if you were driving the browser yourself.")]),e._v(" "),i("p",[e._v("While the learning curve can be steep for Selenium and requires the knowledge of at least one programming language, it has a vast community of active users and even boasts an annual user conference.")]),e._v(" "),i("h5",{attrs:{id:"_5-2-1-1-pros"}},[e._v("5.2.1.1 PROS")]),e._v(" "),i("ul",[i("li",[e._v("Support multiple languages such as ruby, java , C#, python,perl, php")]),e._v(" "),i("li",[e._v("Crossbrowser & paralell testing through saucelab, browserstack")]),e._v(" "),i("li",[e._v("Support multiple automation frameworks such as PageObjectModel, Cucumber, testng etc etc")])]),e._v(" "),i("h5",{attrs:{id:"_5-2-1-2-cons"}},[e._v("5.2.1.2 CONS")]),e._v(" "),i("ul",[i("li",[e._v("Window based application can't be automated")]),e._v(" "),i("li",[e._v("Not suitable for Angular based application")]),e._v(" "),i("li",[e._v("Difficult to manage tool dependencies & libraries")]),e._v(" "),i("li",[e._v("Selenium doesn't directly talk to browser")]),e._v(" "),i("li",[e._v("By default no video capturing, if you are running tests in headless browser")])]),e._v(" "),i("h4",{attrs:{id:"_5-2-2-cypress"}},[e._v("5.2.2 Cypress")]),e._v(" "),i("p",[e._v("So how is Cypress different from Selenium, and how is it the same?")]),e._v(" "),i("p",[e._v("First, Cypress is said to have an easier onboarding than Selenium, where all you need to do is install the .exe to get up and running sine all the drivers and dependencies are automatically installed. With Selenium, on the other hand, you need to spend a little more time getting everything up and running.")]),e._v(" "),i("p",[e._v('Cypress almost acts as a "freemium" model. Similiar to Selenium which is entirely open sourced unless you integrate with a paid tool, you can also add to Cypress\'s core capabilities by leveraging the paid dashboard which includes a test runner that allows you to easily debug tests with DOM snapshots and includes video storage for private projects.')]),e._v(" "),i("p",[e._v("Selenium and Cypress differ in the way of their architecture, as well. Selenium is made up of bindings, or libraries, and the WebDriver, which controls the browsers. These two components work through the JSON network.")]),e._v(" "),i("p",[e._v("Alternatively, while Cypress is used for UI testing, it uses its own unique DOM manipulation and runs directly in the browser with no network communication. Cypress is often cited as a developer-friendly test automation tool for this reason since this often causes frustrations for them in Selenium.")]),e._v(" "),i("p",[e._v("Having a different architecture on top of an Electron app also allows Cypress to be so close to the web application under test that we can do things that you can't do in Selenium such as stubbing DOM APIs.")]),e._v(" "),i("h5",{attrs:{id:"_5-2-2-1-pros"}},[e._v("5.2.2.1 PROS")]),e._v(" "),i("ul",[i("li",[e._v("No need to worry about synchronization issue especially visibility of elements, button or any DOM elements")]),e._v(" "),i("li",[e._v("Easy to setup test development environment through just one click")]),e._v(" "),i("li",[e._v("Ability to capture video recording of tests and it's very useful when tests would have been running in headless browser")]),e._v(" "),i("li",[e._v("Cypress dashboard service")]),e._v(" "),i("li",[e._v("Execution of tests is extremely fast because cypress directly talks to browsers")]),e._v(" "),i("li",[e._v("Stubbing DOM APIs")]),e._v(" "),i("li",[e._v("Most suitable to Reactjs based application")])]),e._v(" "),i("h5",{attrs:{id:"_5-2-2-2-cons"}},[e._v("5.2.2.2 CONS")]),e._v(" "),i("ul",[i("li",[e._v("Window based application can't be automated")]),e._v(" "),i("li",[e._v("Only support chrome browser, so it's crossbrowser compatibility testing is not possible")]),e._v(" "),i("li",[e._v("Doesn't work out of the box with OAuth/OpenID")]),e._v(" "),i("li",[e._v("Only support javascript language for test development")]),e._v(" "),i("li",[e._v("Only support Mocha & Chai framework")]),e._v(" "),i("li",[e._v("Cypress doesn't handle redirects within your applications. Such as if you are going to automate google\n& facebook login scenarios in your application through cypress then you are going have a deep trouble.\nYou will have to write hooks or stubs to achieve this but it's a daunting task")])]),e._v(" "),i("p",[i("strong",[e._v("If you don't know what you're doing when it comes to building out a test automation framework, Cypress may be a good option")])]),e._v(" "),i("h2",{attrs:{id:"_6-synthetic-transactions-tests-running-production"}},[e._v("6. Synthetic Transactions (Tests running production)")]),e._v(" "),i("p",[e._v("Tests carried out on the live production system. They could be set of E2E tests which are continuously running in production and then raise alerts if something fails.")]),e._v(" "),i("h2",{attrs:{id:"_7-stress-load-testing"}},[e._v("7. Stress/Load Testing")]),e._v(" "),i("p",[e._v("Microservices should be able to handle unexpected loads. Stress testing should be used to test the bulk heads in your microservices. If a particular microservice is holding up requests, look at the configured bulk heads.")]),e._v(" "),i("p",[e._v("Gatling is a good tool!")]),e._v(" "),i("p",[e._v("Tests should be automated as part of the build, release, run (delivery) pipeline.")]),e._v(" "),i("p",[e._v("These three sets of tests, combined, should provide an extremely high level of confidence that any introduced change has not broken existing functionality.")]),e._v(" "),i("h1",{attrs:{id:"references"}},[e._v("References")]),e._v(" "),i("ul",[i("li",[e._v("https://martinfowler.com/articles/microservice-testing/")]),e._v(" "),i("li",[e._v("https://www.thoughtworks.com/insights/blog/architecting-continuous-delivery")]),e._v(" "),i("li",[e._v("https://vrockai.github.io/blog/2017/10/28/cypress-keycloak-intregration/")])])])}),[],!1,null,null,null);t.default=o.exports}}]);